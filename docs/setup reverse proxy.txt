Install Putty and connect to remote proxy public ip:
xx.xxx.xxx.xxx:22
login as username, password

Inside the Putty cmd window:
# switch to root user (if not logged in as root)
sudo su -

# To change the password, type:
passwd

# install dependencies
apt update
apt install -y certbot nginx socat tor

# Setup tor
cd /etc/tor
nano torrc

# Inside torrc, we need to have:
SocksPort 9050
RunAsDaemon 1
DataDirectory /var/lib/tor
HiddenServiceDir /var/lib/tor/hidden_service/ssh/
HiddenServicePort 22 127.0.0.1/22

# On the same folder, we find another file too:
nano torsocks.conf

# Inside torsocks.conf we need to have:
TorAddress 127.0.0.1
TorPort 9050

# Navigate into the systemd folder and create a new config file
cd /etc/systemd/system
touch http-to-socks-proxy@.service
nano http-to-socks-proxy@.service

# Add the following lines to the config file
[Unit]
Description=HTTP-to-SOCKS proxy
After=network.target

[Service]
EnvironmentFile=/etc/http-to-socks-proxy/%i.conf
ExecStart=/usr/bin/socat tcp4-LISTEN:${LOCAL_PORT},reuseaddr,fork,keepalive,bind=127.0.0.1 SOCKS4A:${PROXY_HOST}:${REMOTE_HOST}:${REMOTE_PORT},socksport=${PROXY_PORT},connect-timeout=30
RemainAfterExit=no
Restart=always
RestartSec=30s

[Install]
WantedBy=multi-user.target

# [Service]
# RemainAfterExit=yes will leave the service running even after it closed
# Restart=on-failure will only restart if an error code happens
# Restart=always will try to restart all the time upon exit
# RestartSec=30 will wait 30 seconds before attempting to restart the service

# tcp4-LISTEN:
# reuseaddr allows for the service to use the same ip address to listen for new connections
# fork spawns a new child process per connection, if this is disabled, socat will take 1 connection and then exit
# keepalive constantly checks if the connection is still active
# DONT USE: accept-timeout=30 ends waiting for a connection after <seconds> interval with error status.
# this closes the port and stops the service.
# DONT USE: ignoreeof makes the worker stay alive until the server attempts to send that client a message!
# SOCKS:
# connect-timeout=30 aborts the connection attempt after <seconds> [timeval] with error status.
# connect-timeout has to be on the right side of the command [at the end]

# Save the file by doing control+O and then enter, then close # nano by doing control+X
# If a service config file is updated, run systemctl daemon-reload

# create the directory
mkdir -p /etc/http-to-socks-proxy/

# create the file with the content below
nano /etc/http-to-socks-proxy/mmo-server.conf

PROXY_HOST=127.0.0.1
PROXY_PORT=9050
LOCAL_PORT=31590
REMOTE_HOST=n2qrpuhgfkf2rsz75vcupzlouarkywuqkxohybxjdxy4ge3w4ap3fsqd.onion
REMOTE_PORT=31591

# Create a symlink to enable the service and start it
ln -s /etc/systemd/system/http-to-socks-proxy\@.service /etc/systemd/system/multi-user.target.wants/http-to-socks-proxy\@mmo-server.service

# Start it
systemctl start http-to-socks-proxy@mmo-server

# Check service status
systemctl status http-to-socks-proxy@mmo-server

# Check if tunnel is active
netstat -tulpn | grep socat
# should output something like
# tcp 0 0 127.0.0.1:31590 0.0.0.0:* LISTEN 30840/socat

# Create a config file for the domain
cd /etc/nginx/sites-available
touch mmo-server.conf
nano mmo-server.conf

# Add the following code to mmo-server.conf
server {
  listen 2000;
  listen [::]:2000;

  proxy_connect_timeout 30s;
  proxy_send_timeout 120s;
  proxy_read_timeout 120s;
  keepalive_timeout 30s;
  keepalive_time 4h;

  location / {
    proxy_http_version 1.1;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $connection_upgrade;
    proxy_pass http://127.0.0.1:31590/;
  }

  location /ws {
    proxy_http_version 1.1;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $connection_upgrade;
    proxy_pass http://127.0.0.1:31590/ws;
  }
}

# Create a variable mapping to check if the upgrade header is sent by the client
cd /etc/nginx/conf.d
touch map.conf
nano map.conf

# Add the following code to map.conf:
map $http_upgrade $connection_upgrade {
  default upgrade;
  ''      close;
}

# Enable the web server config by creating a symlink
ln -s /etc/nginx/sites-available/mmo-server.conf /etc/nginx/sites-enabled/mmo-server.conf

# Restart nginx
systemctl restart nginx

# To stop apache2 service do
systemctl stop apache2
systemctl disable apache2

# To check if tor service is running
netstat -tulpn | grep 9050

# To check if tor service is enabled on boot
systemctl status tor.service

# To restart tor
systemctl restart tor

# To log out type:
logout

####################################################################################################
# Setup the linux server to host the server directly

# Update the OS and then install the database
sudo apt update
sudo apt install sqlite3

# After copying the sqlite db and the server binary to the /home/draicor folder
# Update the permissions of the file
chmod +x ./mmo-server-linux-arm64-v0.0.1.0

# I ran it in the foreground by using
./mmo-server-linux-arm64-v0.0.1.0

## Setting it up as a Systemd service

# Navigate into the systemd folder and create a new config file
cd /etc/systemd/system
touch mmo-server.service
nano mmo-server.service

# Add the following lines to the config file
[Unit]
Description=MMO Server
After=network.target

[Service]
ExecStart=/home/draicor/mmo-server-linux-arm64-v0.0.1.0
RemainAfterExit=no
Restart=always
RestartSec=30s

[Install]
WantedBy=multi-user.target

# Enable the service and start it
sudo systemctl enable mmo-server.service
sudo systemctl start mmo-server

# Save the file by doing control+O and then enter, then close # nano by doing control+X
# If a service config file is updated, run systemctl daemon-reload

# Everytime we update the server, we need to re-compile the binary, upload it to the remote server
# and then update the service config file and restart it
# Also, we need to pull the db every now and then from the remote server into a secure location.