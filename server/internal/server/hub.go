package server

import (
	"context"
	"database/sql"
	"log"
	"net/http"
	"server/internal/server/db"
	"server/internal/server/objects"
	"server/pkg/packets"
)

// The hub is the entry point for all connected clients and the only go routine
// that should write to the database. It also keeps track of every available region
// within the server.
type Hub struct {
	// Map of all the connected clients in the server
	Clients *objects.MapMutex[Client]

	// Map of every object in the server
	SharedObjects *SharedObjects

	// Packets in this channel will be processed by all connected clients
	BroadcastChannel chan *packets.Packet

	// Clients connected will be added to the Hub
	AddClientChannel chan Client

	// Clients that disconnect will be removed from the Hub
	RemoveClientChannel chan Client

	// Map of every region
	Regions *objects.MapMutex[*Region]

	// Refactor the code so only the hub writes to the DB
	Database *sql.DB
}

// Any state from any client can access and modify these objects
type SharedObjects struct {
	// The ID of the player is the ID of the client
	Players *objects.MapMutex[*objects.Player]
}

// Creates a new empty hub object, we have to pass a valid DB connection
func CreateHub(database *sql.DB) *Hub {
	return &Hub{
		// Collection of every connected client in the server
		Clients:             objects.NewMapMutex[Client](),
		AddClientChannel:    make(chan Client),
		RemoveClientChannel: make(chan Client),
		BroadcastChannel:    make(chan *packets.Packet),
		// Collection of every available region in the server
		Regions: objects.NewMapMutex[*Region](),
		// Database connection
		Database: database,
		// Game objects
		SharedObjects: &SharedObjects{
			Players: objects.NewMapMutex[*objects.Player](),
		},
	}
}

// Creates a client for the new connection and begins the concurrent read and write pumps
func (h *Hub) Serve(getNewClient func(*Hub, http.ResponseWriter, *http.Request) (Client, error), writer http.ResponseWriter, request *http.Request) {
	// Because the connection goes through the onion protocol, the IP gets anonymized, we can only see the port
	log.Println("New client connected from", request.RemoteAddr)

	// Executes the function that was passed as a parameter
	client, err := getNewClient(h, writer, request)

	if err != nil {
		log.Printf("Error obtaining client for new connection: %v\n", err)
		return
	}

	// Send this client to the add client channel
	h.AddClientChannel <- client

	// Sends packets to the game client
	go client.StartWritePump()
	// Reads packets from the game client
	go client.StartReadPump()
}

// Listens for packets on each channel
func (h *Hub) Start() {
	log.Println("Starting hub...")

	h.CreateRegion("Prototype", "prototype")

	log.Println("Hub created, awaiting clients...")

	// Infinite for loop
	for {
		// If there is no default case, the "select" statement blocks
		// until at least one of the communications can proceed
		select {

		// If a client connects to the server, add it to the Hub
		case client := <-h.AddClientChannel:
			// The Add method returns a client ID, which we use to Initialize the WebSocket Client's ID
			client.Initialize(h.Clients.Add(client))

		// If a client disconnects, remove him from the Hub
		case client := <-h.RemoveClientChannel:
			h.Clients.Remove(client.GetId())

		// If we get a packet from the broadcast channel
		case packet := <-h.BroadcastChannel:
			// Go over every registered client in the Hub (whole server)
			h.Clients.ForEach(func(id uint64, client Client) {
				// Check that the sender does not send the packet to itself
				if client.GetId() != packet.SenderId {
					client.ProcessPacket(packet.SenderId, packet.Payload)
				}
			})
		}
	}
}

// Each client interfacer will have its own database transaction context
type DBTX struct {
	Ctx     context.Context
	Queries *db.Queries
}

// Creates a basic context and holds a reference to the SQL Queries generated by sqlc
func (h *Hub) NewDBTX() *DBTX {
	return &DBTX{
		Ctx:     context.Background(),
		Queries: db.New(h.Database),
	}
}

// Retrieves the client (if found) in the Clients collection
func (h *Hub) GetClient(id uint64) (Client, bool) {
	return h.Clients.Get(id)
}

// Retrieves the region (if found) in the Regions collection
func (h *Hub) GetRegionById(id uint64) (*Region, bool) {
	region, found := h.Regions.Get(id)
	if found {
		return region, true
	}
	return nil, false
}

// Creates a new region and adds it to Hub
func (h *Hub) CreateRegion(name string, gameMap string) {
	region := CreateRegion(name, gameMap)

	// Dereference the pointer to add a REAL region object to the Hub's list of regions
	// If this is the first region, h.Regions.Add returns 1, and the initial value for the region was 0
	region.SetId(h.Regions.Add(region))

	// Start the region in a goroutine
	go region.Start()
}

// Registers the client to this region if it exists and its available
func (h *Hub) JoinRegion(clientId uint64, regionId uint64) {
	// Search for this client by id
	client, clientExists := h.GetClient(clientId)
	// If the client is online and exists
	if clientExists {

		// Search for this region by id
		region, regionExists := h.GetRegionById(regionId)
		// If the region is valid
		if regionExists {

			// TO DO ->
			// CHECK IF CLIENT CAN JOIN THIS REGION (LEVEL REQ)

			// If the client was already at another region
			if client.GetRegion() != nil {
				// Broadcast to everyone that this client left this region!
				client.Broadcast(packets.NewClientLeft(client.GetId(), client.GetPlayerCharacter().Name))
				// Unregister the client from that region
				client.GetRegion().RemoveClientChannel <- client
			}

			// Register the client to the new region
			region.AddClientChannel <- client
			// Save the new region pointer in the client
			client.SetRegion(region)

		} else { // If the region does not exist
			log.Printf("Region %d not available", regionId)
		}
	}
}
