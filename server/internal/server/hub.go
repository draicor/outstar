package server

import (
	"context"
	"database/sql"
	"log"
	"net/http"
	"server/internal/server/db"
	"server/internal/server/objects"
	"server/pkg/packets"
)

// The hub is the entry point for all connected clients and the only go routine
// that should write to the database. It also keeps track of every available room
// within the server.
type Hub struct {
	// Map of all the connected clients in the server
	Clients *objects.SharedCollection[ClientInterfacer]

	// Players connected counter
	PlayersOnline uint64

	// Packets in this channel will be processed by all connected clients
	BroadcastChannel chan *packets.Packet

	// Clients connected will be added to the Hub
	AddClientChannel chan ClientInterfacer

	// Clients that disconnect will be removed from the Hub
	RemoveClientChannel chan ClientInterfacer

	// Map of every available room
	Rooms *objects.SharedCollection[*Room]

	// Every new room will get a reference to the database connection pool
	DatabasePool *sql.DB

	// Database write queries received on this channel will be queued for execution
	// Only rooms should request the hub to write something
	DatabaseChannel chan *db.Queries
}

type SharedGameObjects struct {
	// The ID of the player is the ID of the client
	Players *objects.SharedCollection[*objects.Player]
}

// Creates a new empty hub object, we have to pass a valid DB connection
func CreateHub(databasePool *sql.DB) *Hub {
	return &Hub{
		// Collection of every connected client in the server
		Clients:             objects.NewSharedCollection[ClientInterfacer](),
		PlayersOnline:       0,
		AddClientChannel:    make(chan ClientInterfacer),
		RemoveClientChannel: make(chan ClientInterfacer),
		BroadcastChannel:    make(chan *packets.Packet),
		// Collection of every available room in the server
		Rooms: objects.NewSharedCollection[*Room](),
		// Database connection
		DatabasePool: databasePool,
		// TO FIX -> CHANGE THE TYPE OF THE CHANNELs
		DatabaseChannel: make(chan *db.Queries),
	}
}

// Creates a client for the new connection and begins the concurrent read and write pumps
func (h *Hub) Serve(getNewClient func(*Hub, http.ResponseWriter, *http.Request) (ClientInterfacer, error), writer http.ResponseWriter, request *http.Request) {
	// Because the connection goes through the onion protocol, the IP gets anonymized, we can only see the port
	log.Println("New client connected from", request.RemoteAddr)

	// Executes the function that was passed as a parameter
	client, err := getNewClient(h, writer, request)

	if err != nil {
		log.Printf("Error obtaining client for new connection: %v\n", err)
		return
	}

	// Send this client to the add client channel
	h.AddClientChannel <- client

	// Sends packets to the godot websocket client
	go client.WritePump()
	// Reads packets from the godot websocket client and process them
	go client.ReadPump()
}

// Listens for packets on each channel
func (h *Hub) Start() {
	log.Println("Hub created, awaiting client connections...")

	// Infinite for loop
	for {
		// If there is no default case, the "select" statement blocks
		// until at least one of the communications can proceed
		select {

		// If a client connects to the server, add it to the Hub
		case client := <-h.AddClientChannel:
			// If this client already has an ID
			if client.HasId() {
				// We just add him to the Hub with the same ID he had before
				h.Clients.Add(client, client.GetId())
			} else { // First time joining the Hub after login
				// The Add method returns a client ID, which we use to Initialize the WebSocket Client's ID
				client.Initialize(h.Clients.Add(client))
			}

			// We increase the number of players online only after login
			h.PlayersOnline++

		// If a client disconnects, remove him from the Hub
		case client := <-h.RemoveClientChannel:
			h.Clients.Remove(client.GetId())
			h.PlayersOnline--

		// If we get a packet from the broadcast channel
		case packet := <-h.BroadcastChannel:
			// Go over every registered client in the Hub (whole server)
			h.Clients.ForEach(func(id uint64, client ClientInterfacer) {
				// Check that the sender does not send the message to itself
				if client.GetId() != packet.SenderId {
					// If the client is not idling at the login/register screen
					if client.GetNickname() != "" {
						client.ProcessMessage(packet.SenderId, packet.Payload)
					}
				}
			})
		}
	}
}

// Each client interfacer will have its own database transaction context
type DBTX struct {
	Ctx     context.Context
	Queries *db.Queries
}

// Creates a basic context and holds a reference to the SQL Queries generated by sqlc
func (h *Hub) NewDBTX() *DBTX {
	return &DBTX{
		Ctx:     context.Background(),
		Queries: db.New(h.DatabasePool),
	}
}

// Retrieves the client (if found) in the Clients collection
func (h *Hub) GetClient(id uint64) (ClientInterfacer, bool) {
	return h.Clients.Get(id)
}

// Retrieves the room (if found) in the Rooms collection
func (h *Hub) GetRoom(id uint64) (*Room, bool) {
	room, found := h.Rooms.Get(id)
	if found {
		return room, true
	}
	return nil, false
}

// Creates a new room adds it to the list of available rooms
func (h *Hub) CreateRoom(maxPlayers uint64) *Room {
	// Create it with the next id counter from the Hub
	room := CreateRoom(maxPlayers)

	// Dereference the pointer to add a REAL room object to the Hub's list of rooms
	// If this is the first room, h.Rooms.Add returns 1, and the initial value for the room was 0
	room.SetId(h.Rooms.Add(room))

	// Start the room in a goroutine
	go room.Start()

	// Pass the pointer of this room to the client
	return room
}

// Registers the client to this room if it exists and its available
func (h *Hub) JoinRoom(clientId uint64, roomId uint64) *Room {
	// Search for this client by id
	_, clientExists := h.GetClient(clientId)
	// If the client is online and exists
	if clientExists {

		// Search for this room by id
		room, roomExists := h.GetRoom(roomId)
		// If the room is already created
		if roomExists {

			// TO DO ->
			// CHECK IF CLIENT CAN JOIN THIS ROOM (ROOM NOT FULL)

			// TO DO ->
			// Unregister the client from the LOBBY, not the hub

			// Unregister the client from the hub
			// The underlying connection to the websocket will remain, but he won't
			// be sending packets directly to the hub, only to the room hes at
			h.Clients.Remove(clientId)

			// Pass a pointer of this room to the client
			// Return true to let the client know he can join immediately
			return room

		} else { // If the room does not exist
			log.Println("Room", roomId, "doesn't exist in the Hub ")
			return nil
		}
	}

	log.Println("Client", clientId, "not in lobby tried to join room", roomId)

	// If the client is not online in the Hub, we return nil
	return nil
}

// Returns the channel that can broadcast packets
func (h *Hub) GetBroadcastChannel() chan *packets.Packet {
	return h.BroadcastChannel
}

// Returns the channel that registers new clients
func (h *Hub) GetAddClientChannel() chan ClientInterfacer {
	return h.AddClientChannel
}

// Returns the channel that removes clients
func (h *Hub) GetRemoveClientChannel() chan ClientInterfacer {
	return h.RemoveClientChannel
}

// Returns the collection of rooms
func (h *Hub) GetRooms() *objects.SharedCollection[*Room] {
	return h.Rooms
}
