// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const createCharacter = `-- name: CreateCharacter :one
INSERT INTO characters (user_id, gender, region_id, map_id, x, z, health, max_health, speed, rotation_y, is_crouching)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, user_id, gender, region_id, map_id, x, z, health, max_health, speed, rotation_y, weapon_slot, is_crouching
`

type CreateCharacterParams struct {
	UserID      int64
	Gender      string
	RegionID    int64
	MapID       int64
	X           int64
	Z           int64
	Health      int64
	MaxHealth   int64
	Speed       int64
	RotationY   float64
	IsCrouching int64
}

// Character Operations
func (q *Queries) CreateCharacter(ctx context.Context, arg CreateCharacterParams) (Character, error) {
	row := q.db.QueryRowContext(ctx, createCharacter,
		arg.UserID,
		arg.Gender,
		arg.RegionID,
		arg.MapID,
		arg.X,
		arg.Z,
		arg.Health,
		arg.MaxHealth,
		arg.Speed,
		arg.RotationY,
		arg.IsCrouching,
	)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Gender,
		&i.RegionID,
		&i.MapID,
		&i.X,
		&i.Z,
		&i.Health,
		&i.MaxHealth,
		&i.Speed,
		&i.RotationY,
		&i.WeaponSlot,
		&i.IsCrouching,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (username, nickname, password_hash)
VALUES (?, ?, ?)
RETURNING id, username, nickname, password_hash
`

type CreateUserParams struct {
	Username     string
	Nickname     string
	PasswordHash string
}

type CreateUserRow struct {
	ID           int64
	Username     string
	Nickname     string
	PasswordHash string
}

// User Operations
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Username, arg.Nickname, arg.PasswordHash)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Nickname,
		&i.PasswordHash,
	)
	return i, err
}

const deleteWeaponSlots = `-- name: DeleteWeaponSlots :exec
DELETE FROM character_weapons WHERE character_id = ?
`

// Weapon Slot Operations
func (q *Queries) DeleteWeaponSlots(ctx context.Context, characterID int64) error {
	_, err := q.db.ExecContext(ctx, deleteWeaponSlots, characterID)
	return err
}

const getCharacterByID = `-- name: GetCharacterByID :one
SELECT id, user_id, gender, region_id, map_id, x, z, health, max_health, speed, rotation_y, weapon_slot, is_crouching FROM characters WHERE id = ?
`

func (q *Queries) GetCharacterByID(ctx context.Context, id int64) (Character, error) {
	row := q.db.QueryRowContext(ctx, getCharacterByID, id)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Gender,
		&i.RegionID,
		&i.MapID,
		&i.X,
		&i.Z,
		&i.Health,
		&i.MaxHealth,
		&i.Speed,
		&i.RotationY,
		&i.WeaponSlot,
		&i.IsCrouching,
	)
	return i, err
}

const getCharacterByUserID = `-- name: GetCharacterByUserID :one
SELECT id, user_id, gender, region_id, map_id, x, z, health, max_health, speed, rotation_y, weapon_slot, is_crouching FROM characters WHERE user_id = ?
`

func (q *Queries) GetCharacterByUserID(ctx context.Context, userID int64) (Character, error) {
	row := q.db.QueryRowContext(ctx, getCharacterByUserID, userID)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Gender,
		&i.RegionID,
		&i.MapID,
		&i.X,
		&i.Z,
		&i.Health,
		&i.MaxHealth,
		&i.Speed,
		&i.RotationY,
		&i.WeaponSlot,
		&i.IsCrouching,
	)
	return i, err
}

const getCharacterPosition = `-- name: GetCharacterPosition :one
SELECT region_id, map_id, x, z FROM characters WHERE id = ? LIMIT 1
`

type GetCharacterPositionRow struct {
	RegionID int64
	MapID    int64
	X        int64
	Z        int64
}

func (q *Queries) GetCharacterPosition(ctx context.Context, id int64) (GetCharacterPositionRow, error) {
	row := q.db.QueryRowContext(ctx, getCharacterPosition, id)
	var i GetCharacterPositionRow
	err := row.Scan(
		&i.RegionID,
		&i.MapID,
		&i.X,
		&i.Z,
	)
	return i, err
}

const getFullCharacterData = `-- name: GetFullCharacterData :one
SELECT
  c.id, c.gender, c.region_id, c.map_id, c.x, c.z, c.health, c.max_health, c.speed, c.rotation_y, c.weapon_slot, c.is_crouching,
  u.username, u.nickname
FROM characters c
JOIN users u ON c.user_id = u.id
WHERE c.id = ?
`

type GetFullCharacterDataRow struct {
	ID          int64
	Gender      string
	RegionID    int64
	MapID       int64
	X           int64
	Z           int64
	Health      int64
	MaxHealth   int64
	Speed       int64
	RotationY   float64
	WeaponSlot  int64
	IsCrouching int64
	Username    string
	Nickname    string
}

func (q *Queries) GetFullCharacterData(ctx context.Context, id int64) (GetFullCharacterDataRow, error) {
	row := q.db.QueryRowContext(ctx, getFullCharacterData, id)
	var i GetFullCharacterDataRow
	err := row.Scan(
		&i.ID,
		&i.Gender,
		&i.RegionID,
		&i.MapID,
		&i.X,
		&i.Z,
		&i.Health,
		&i.MaxHealth,
		&i.Speed,
		&i.RotationY,
		&i.WeaponSlot,
		&i.IsCrouching,
		&i.Username,
		&i.Nickname,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, nickname, password_hash, character_id FROM users WHERE id = ?
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Nickname,
		&i.PasswordHash,
		&i.CharacterID,
	)
	return i, err
}

const getUserByNickname = `-- name: GetUserByNickname :one
SELECT id, username, nickname, password_hash, character_id
FROM users
WHERE nickname = ?
LIMIT 1
`

func (q *Queries) GetUserByNickname(ctx context.Context, nickname string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByNickname, nickname)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Nickname,
		&i.PasswordHash,
		&i.CharacterID,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, nickname, password_hash, character_id
FROM users
WHERE username = ? COLLATE NOCASE
LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Nickname,
		&i.PasswordHash,
		&i.CharacterID,
	)
	return i, err
}

const insertWeaponSlot = `-- name: InsertWeaponSlot :exec
INSERT INTO character_weapons
  (character_id, slot_index, weapon_name, weapon_type, display_name, ammo, fire_mode)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type InsertWeaponSlotParams struct {
	CharacterID int64
	SlotIndex   int64
	WeaponName  string
	WeaponType  string
	DisplayName string
	Ammo        int64
	FireMode    int64
}

func (q *Queries) InsertWeaponSlot(ctx context.Context, arg InsertWeaponSlotParams) error {
	_, err := q.db.ExecContext(ctx, insertWeaponSlot,
		arg.CharacterID,
		arg.SlotIndex,
		arg.WeaponName,
		arg.WeaponType,
		arg.DisplayName,
		arg.Ammo,
		arg.FireMode,
	)
	return err
}

const loadWeaponSlots = `-- name: LoadWeaponSlots :many
SELECT slot_index, weapon_name, weapon_type, display_name, ammo, fire_mode
FROM character_weapons
WHERE character_id = ?
`

type LoadWeaponSlotsRow struct {
	SlotIndex   int64
	WeaponName  string
	WeaponType  string
	DisplayName string
	Ammo        int64
	FireMode    int64
}

func (q *Queries) LoadWeaponSlots(ctx context.Context, characterID int64) ([]LoadWeaponSlotsRow, error) {
	rows, err := q.db.QueryContext(ctx, loadWeaponSlots, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LoadWeaponSlotsRow
	for rows.Next() {
		var i LoadWeaponSlotsRow
		if err := rows.Scan(
			&i.SlotIndex,
			&i.WeaponName,
			&i.WeaponType,
			&i.DisplayName,
			&i.Ammo,
			&i.FireMode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setUserCharacterID = `-- name: SetUserCharacterID :exec
UPDATE users SET character_id = ? WHERE id = ?
`

type SetUserCharacterIDParams struct {
	CharacterID sql.NullInt64
	ID          int64
}

func (q *Queries) SetUserCharacterID(ctx context.Context, arg SetUserCharacterIDParams) error {
	_, err := q.db.ExecContext(ctx, setUserCharacterID, arg.CharacterID, arg.ID)
	return err
}

const updateCharacterStats = `-- name: UpdateCharacterStats :exec
UPDATE characters
set health = ?, max_health = ?
WHERE id = ?
`

type UpdateCharacterStatsParams struct {
	Health    int64
	MaxHealth int64
	ID        int64
}

func (q *Queries) UpdateCharacterStats(ctx context.Context, arg UpdateCharacterStatsParams) error {
	_, err := q.db.ExecContext(ctx, updateCharacterStats, arg.Health, arg.MaxHealth, arg.ID)
	return err
}

const updateFullCharacterData = `-- name: UpdateFullCharacterData :exec
UPDATE characters
SET
  region_id = ?, map_id = ?, x = ?, z = ?, health = ?, max_health = ?, speed = ?, rotation_y = ?, weapon_slot = ?, is_crouching = ?
WHERE id = ?
`

type UpdateFullCharacterDataParams struct {
	RegionID    int64
	MapID       int64
	X           int64
	Z           int64
	Health      int64
	MaxHealth   int64
	Speed       int64
	RotationY   float64
	WeaponSlot  int64
	IsCrouching int64
	ID          int64
}

func (q *Queries) UpdateFullCharacterData(ctx context.Context, arg UpdateFullCharacterDataParams) error {
	_, err := q.db.ExecContext(ctx, updateFullCharacterData,
		arg.RegionID,
		arg.MapID,
		arg.X,
		arg.Z,
		arg.Health,
		arg.MaxHealth,
		arg.Speed,
		arg.RotationY,
		arg.WeaponSlot,
		arg.IsCrouching,
		arg.ID,
	)
	return err
}
